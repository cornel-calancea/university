%include "io.inc"
extern getAST
extern freeAST
extern printTree



section .bss
    ; La aceasta adresa, scheletul stocheaza radacina arborelui
    root: resd 1

section .text
global main
main:
    mov ebp, esp; for correct debugging
    ; NU MODIFICATI
    push ebp
    mov ebp, esp
    
    ; Se citeste arborele si se scrie la adresa indicata mai sus
    call getAST
    mov [root], eax;    
    ; Implementati rezolvarea aici:
    mov ebx, [eax]
    PRINT_STRING [ebx];
    PRINT_DEC 1, [ebx];
    
    ;trimit parametrii si apelez functia care sa-mi printeze arborele
    push 0;
    push eax;
    call printTree
    add esp, 8;
;   
    mov eax, [root]; 
    push eax;
    ;PRINT_STRING "[eax] before createStack : ";
    ;PRINT_DEC 4, [eax];
    ;NEWLINE;
    call evaluate;
    add esp, 4;
    ;PRINT_STRING "eax after createStack : ";
    ;PRINT_DEC 4, eax;
    ;NEWLINE;
    
    
    ; NU MODIFICATI
    ; Se elibereaza memoria alocata pentru arbore
    push dword [root]
    call freeAST
    
    xor eax, eax
    leave
    ret

evaluate:
    push ebp;
    mov ebp, esp;
    
    ;PRINT_STRING "entered evaluate";
    ;NEWLINE;
    
    xor eax, eax; clear eax and ebx
    xor ebx, ebx;
    
    mov eax, [ebp+8]; getting the argument - pointer to the root
    push eax; storing the root adress on the stack
    mov ebx, [eax]; ebx contains the value of data(a pointer to a string)
    
    push ebx;
    PRINT_STRING "EBX before isOperand : ";
    PRINT_DEC 4, ebx;
    NEWLINE;
    call isOperand;
    PRINT_STRING "EBX after isOperand : ";
    PRINT_DEC 4, ebx;
    NEWLINE;
    add esp, 4; remains unchanged???
    ;NEWLINE;
    
    mov edx, eax; atent ce se intampla aici - not my code; edx has return value of isOperand
    ;pop eax; eax now contains the pointer to the root(pushed at line 62)
    cmp edx, 1;
    jz return_value;
    
    ;if is operator
    ;pop eax; extract the address from the stack
    mov edx, [esp]; top stack - get root
    add edx, 4; make edx point to left branch
    ;PRINT_STRING "[edx] (left branch) : ";
    ;PRINT_DEC 4, [edx];
    ;NEWLINE;
        
    push edx; push left branch of tree;
    call evaluate;
    add esp, 4;
    
    ;PRINT_STRING "edx after evaluate : ";
    ;PRINT_DEC 4, edx;
    ;NEWLINE;
    
    mov ebx, eax;   STUPID LINE NO.1
    PRINT_STRING "LEFT BRANCH EVALUATION : ";
    PRINT_DEC 4, eax;
    NEWLINE;
    mov edx, [esp]; top stack - get root
    ;pop edx; extract root value from stack - it will be no longer needed
    add edx, 8; make edx point to right branch of the tree
    
    ;PRINT_STRING "[edx] right branch: "; problem - eax now contains the return value of evaluate
    ;PRINT_DEC 4, edx;
    ;NEWLINE;
            
    push edx; push right branch of tree;
    call evaluate;
    add esp, 4;
    
    PRINT_STRING "RIGHT BRANCH EVALUATION : ";
    PRINT_DEC 4, eax;
    NEWLINE;
    
    xchg eax, ebx;  STUPID LINE NO.2, eax stores left operand, ebx the right operand
    PRINT_STRING "registers : ";
    PRINT_DEC 4, eax;
    NEWLINE;
    PRINT_DEC 4, ebx;
    NEWLINE;
    PRINT_DEC 4, [edx];
    
    cmp byte[ebx], 42;
    jz multiplication;
    cmp byte[ebx], 43;
    jz addition;
    cmp byte[ebx], 45;
    jz subtraction;
    cmp byte[ebx], 47;
    jz division;    
multiplication:
    
addition:
    add eax, ebx;
    jmp return_operation_result;
subtraction:
    sub eax, ebx;
    jmp return_operation_result;
division:

return_operation_result:    
    leave;
    ret;
    
return_value:
    PRINT_STRING "given string : ";
    PRINT_DEC 4, [ebx];
    NEWLINE;
    push ebx;
    call toInt; the value is already stored in eax so we can return it
    add esp, 4;
    PRINT_STRING "EAX after toInt : ";
    PRINT_DEC 4, eax;
    NEWLINE;   
     
    pop edx; pop pushed root address
    
    
    ;PRINT_STRING "End of evaluate. ESP : "
    ;PRINT_DEC 4, esp;
    ;NEWLINE;
    ;PRINT_STRING "EBP : ";
    ;PRINT_DEC 4, ebp;
    ;NEWLINE;
    leave;
    ret;
    
;function that returns 1 if given string represents an operand
isOperand:
    push ebp;
    mov ebp, esp;
    
    xor eax, eax;
    mov edi, [ebp+8]; edi now points to the string;
    mov al, 0x00; null terminator
    repne scasb; make edi point to the character following null terminator
    sub edi, 2; edi points to the last character of the string
    cmp byte[edi], 48; see if the last character is an operator or a number
    jl no;
    inc eax;
no:
    leave; 
    ret;

;function that converts a string to an integer
toInt:
    push ebp;
    mov ebp, esp;
    
    xor edx, edx; clear edx
    xor eax, eax; clear eax
    xor ecx, ecx;
    mov ebx, 10; multiplication factor
    mov edi, [ebp+8]; edi contains the adress of the string
    PRINT_STRING "received value : "
    PRINT_STRING [edi];
    NEWLINE;
    cmp byte[edi], 45; see if the first character is '-'
    jnz pushSign; push 0 on stack
    ;sets the sign bit in edx
    mov edx, 1;
    inc edi; //go to the next character
pushSign:
    push edx;
getByte:
    mul ebx;
    mov cl, byte[edi]; transfer the ascii value of the character to ecx
    sub cl, 48; convert to actual number value
    add eax, ecx;
    inc edi;
    cmp byte[edi], 0x00;
    jne getByte;
    pop edx;
    cmp edx, 0; if edx was set, we need to negate the number
    je end;
    neg eax;
end:

    leave;
    ret;
   
  
